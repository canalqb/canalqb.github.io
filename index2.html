<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<title>Grade 16×16 — Private HEX + WIFs</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="css/styles.css">
</head>
<body>
  <div id="container">
    <h1>Grade 16×16 — Private HEX + WIFs</h1>

    <label class="section">Descrição</label>
    <textarea rows="3" readonly style="width:100%; box-sizing:border-box; border:2px solid var(--green); border-radius:6px; padding:8px;">
A cada alteração nas linhas 9 a 16 da grade, é gerada uma Private Key (HEX) de 256 bits, o WIF Comprimido (começa com 5) e o WIF Não Comprimido (começa com K ou L).
    </textarea>

    <div class="canvas-wrap" style="margin-top:14px;">
      <div style="min-width:520px;">
        <label class="section">Grade (clique para alternar célula)</label>
        <canvas id="grid" width="512" height="512"></canvas>
        <div class="legend">Linha 1 ↑ — Linha 16 ↓</div>
        <div class="controls" style="margin-top:12px;">
          <button class="btn" onclick="initGrid(); drawGrid();">Limpar</button>
        </div>
      </div>

      <div style="min-width:300px; max-width:420px; text-align:left;">
        <label class="section">Notas</label>
        <div style="font-size:0.9rem;">
          <ul style="margin:6px 0 0 18px; padding:0;">
            <li>Linhas afetadas: 9 a 16.</li>
            <li>Cada clique em uma dessas linhas gera HEX, WIF comprimido e não comprimido.</li>
            <li>Sem duplicações consecutivas.</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="logs">
      <div>
        <label class="section">Private Keys (HEX)</label>
        <textarea id="privateKeysBox" class="logbox" readonly></textarea>
      </div>

      <div>
        <label class="section">WIFs (Comprimido - começam com 5)</label>
        <textarea id="wifBox" class="logbox" readonly></textarea>
      </div>

      <div>
        <label class="section">WIFs (Não Comprimido - começam com K ou L)</label>
        <textarea id="wifBoxUncompressed" class="logbox" readonly></textarea>
      </div>
    </div>

    <div style="margin-top:18px;">
      <button class="btn" onclick="exportLog('privateKeysBox', 'private_keys_hex.txt')">Exportar HEX</button>
      <button class="btn" onclick="exportLog('wifBox', 'wif_comprimido.txt')">Exportar WIF Comprimido</button>
      <button class="btn" onclick="exportLog('wifBoxUncompressed', 'wif_nao_comprimido.txt')">Exportar WIF Não Comprimido</button>
    </div>

    <footer style="margin-top:20px; font-size:0.85rem; color:#777;">&copy; Grade 16×16 — Exemplo</footer>
  </div>

<script>
(async function () {
  const canvas = document.getElementById('grid');
  const ctx = canvas.getContext('2d', { alpha: false });
  const GRID = 16;
  const CELL = canvas.width / GRID;
  let grid = [];

  const rowsToWatch = { start: 8, end: 15 };

  const privateKeysBox = document.getElementById('privateKeysBox');
  const wifBox = document.getElementById('wifBox');
  const wifBoxUncompressed = document.getElementById('wifBoxUncompressed');

  let lastHex = '', lastWif = '', lastWifUncompressed = '';

  const BASE58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

  function initGrid() {
    grid = Array.from({ length: GRID }, () => Array(GRID).fill(false));
  }

  function drawGrid() {
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let r = 0; r < GRID; r++) {
      for (let c = 0; c < GRID; c++) {
        const x = c * CELL, y = r * CELL;
        ctx.fillStyle = grid[r][c] ? '#006400' : '#ffffff';
        ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);
        ctx.strokeStyle = '#008000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 0.5, y + 0.5, CELL - 1, CELL - 1);
      }
    }
  }

  function bitsFromGrid() {
    return grid.flat().map(b => b ? '1' : '0').join('');
  }

  function hexFromBits(bits) {
    return bits.match(/.{1,4}/g).map(b => parseInt(b, 2).toString(16)).join('').padStart(64, '0');
  }

  function hexToBytes(hex) {
    return Uint8Array.from(hex.match(/.{2}/g).map(b => parseInt(b, 16)));
  }

  function concatBytes(...arrays) {
    return Uint8Array.from(arrays.flatMap(a => Array.from(a)));
  }

  async function sha256(buf) {
    const hash = await crypto.subtle.digest('SHA-256', buf);
    return new Uint8Array(hash);
  }

  async function doubleSha256(buf) {
    return await sha256(await sha256(buf));
  }

  function bytesToBase58(bytes) {
    let n = 0n;
    for (const b of bytes) {
      n = (n << 8n) + BigInt(b);
    }
    let result = '';
    while (n > 0n) {
      const mod = n % 58n;
      n = n / 58n;
      result = BASE58[Number(mod)] + result;
    }
    // Count leading zeros
    let leadingZeros = 0;
    for (const b of bytes) {
      if (b === 0) leadingZeros++;
      else break;
    }
    return '1'.repeat(leadingZeros) + result;
  }

  async function privateKeyToWIF(hex, compressed = true) {
    const key = hexToBytes(hex.padStart(64, '0'));
    const prefix = Uint8Array.of(0x80);
    const suffix = compressed ? Uint8Array.of(0x01) : new Uint8Array([]);
    const payload = concatBytes(prefix, key, suffix);
    const checksum = (await doubleSha256(payload)).slice(0, 4);
    const full = concatBytes(payload, checksum);
    return bytesToBase58(full);
  }

  function updateLogs(hex, wifComp, wifUncomp) {
    if (hex && hex !== lastHex) {
      privateKeysBox.value += hex + '\n';
      lastHex = hex;
    }
    if (wifComp && wifComp !== lastWif) {
      wifBox.value += wifComp + '\n';
      lastWif = wifComp;
    }
    if (wifUncomp && wifUncomp !== lastWifUncompressed) {
      wifBoxUncompressed.value += wifUncomp + '\n';
      lastWifUncompressed = wifUncomp;
    }
  }

  function cellIndexFromCoord(x, y) {
    const col = Math.floor(x / CELL);
    const row = Math.floor(y / CELL);
    if (col >= 0 && col < GRID && row >= 0 && row < GRID) {
      return { row, col };
    }
    return null;
  }

  function toggleCell(row, col) {
    grid[row][col] = !grid[row][col];
  }

  async function handleGridChange() {
    drawGrid();

    // Apenas processar linhas 9 a 16 (índices 8 a 15)
    let bits = '';
    for (let r = rowsToWatch.start; r <= rowsToWatch.end; r++) {
      bits += grid[r].map(b => b ? '1' : '0').join('');
    }

    const hex = hexFromBits(bits);
    const wifComp = await privateKeyToWIF(hex, true);
    const wifUncomp = await privateKeyToWIF(hex, false);

    // Só atualiza se for diferente da última entrada para evitar duplicação
    if (privateKeysBox.value.trim().split('\n').pop() !== hex) {
      updateLogs(hex, wifComp, wifUncomp);
    }
  }

  canvas.addEventListener('click', async e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const idx = cellIndexFromCoord(x, y);
    if (!idx) return;

    toggleCell(idx.row, idx.col);

    // Só processa se estiver na linha de interesse
    if (idx.row >= rowsToWatch.start && idx.row <= rowsToWatch.end) {
      await handleGridChange();
    } else {
      drawGrid();
    }
  });

  function exportLog(id, filename) {
    const data = document.getElementById(id).value;
    const blob = new Blob([data], { type: 'text/plain;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  window.initGrid = initGrid;
  window.drawGrid = drawGrid;
  window.exportLog = exportLog;

  initGrid();
  drawGrid();
})();
</script>
</body>
</html>
